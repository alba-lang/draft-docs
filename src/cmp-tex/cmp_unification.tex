\section{Unification}






\subsection{Description of the Problem}
%--------------------------------------------------------------------------------

Whenever a function is applied to an actual argument then the type of the actual
argument $A$ has to be a subtype of the type of the formal argument $R$ i.e. $A
\le R$ has to be valid. Otherwise the actual argument is not a legal argument to
the function. Without metavariables and performance considerations the solution
is quite simple:

\begin{itemize}

    \item Transform both types into normal form. Since both are types their normal
        forms have to be products with zero or more arguments and the result type is
        either a sort or a base term i.e. the have one of the forms
        $$
        \begin{array}{l}
            \Pi x_1^{A_1} \ldots x_n^{A_n}. x \vec a
            \\
            \Pi x_1^{A_1} \ldots x_n^{A_n}. s
        \end{array}
        $$

    \item Check that both have the same number of arguments and  all argument types
        are identical.

    \item The result types have to be either both base terms or sorts. In case of
        base terms both have to be identical. In case of sorts the sort of the actual
        argument type has to be a subtype of the sort of the formal argument type.

\end{itemize}


There are two problems with this approach:

\begin{itemize}

    \item The source code is not fully annotated. Metavariables are introduced
        during elaboration for terms missing in the source code. The elaborator
        has to instantiate these metavariables.

    \item A complete normalization performs a lot of function unfolding, case
        expression reductions, let term reductions and beta reductions.
        Operation of let and beta reduction is variable substitution in terms.
        Since variables can occur several times in terms the normalized terms
        can be considerably large even growing exponentially. Consider that
        there are 10 beta reductions which duplicate a term. If this duplication
        is nested then there are finally 1014 duplicates.

        Furthermore case term reductions can grow exponentially in the worst
        case.

        Therefore reduction to complete normal form can be a performance
        problem.
\end{itemize}


We work with contexts
$$
    \Gamma ::= [] \mid \Gamma,x^A \mid \Gamma, x^A := a \mid \Gamma, \meta m^M
                \mid \Gamma, \meta m^M := a
$$
Clearly duplicate names are not allowed.

The unification problem looks like
$$
\Gamma \vdash A \le R
$$
where $A$ and $R$ are welltyped in the context $\Gamma$.





\subsection{Metavariables}
%--------------------------------------------------------------------------------


Metavariables are introduced when there is something unknown in a certain
context (e.g. a missing type, an implicit variable). Each metavariable has a
type $\Gamma \vdash \meta m : M$. I.e. metavariables are required to be
welltyped.

The type $M$ of a metavariable is a required type. The actual type used in
instantiations can be a subtype of $M$.

If we have two metavariables $\meta m_1$ and $\meta m_2$ and both are separated
in the context by a free variable (i.e. variable without definition $\Gamma = [
    \ldots, \meta m_1^{M_1}, \ldots x^A, \ldots, \meta m_2^{M_2}, \ldots]$) then
the meta variable $m_2$ is an \emph{inner metavariable} with respect to $\meta
m_1$. Metavariables which are not separated by free variables are in the same
group.

There are the following reasons to introduce metavariables:
\begin{enumerate}
    \item Missing type annotation: In the source code a variable is introduced
        without an explicit type (e.g. types in global or local definitions,
        argument type of an a abstraction or a product, argument type of a let
        binding). The usage of the variable shall finally instantiate the
        metavariable standing for the type.

    \item Implicit actual argument: In a function application the implicit
        arguments can be ommitted in the source code. For each implicit actual
        argument a metavariable is introduced. Usually the implicit argument is
        used in one of the subsequent argument types or in the result type.
        Having these types the implicit argument can be instantiated.

    \item Interleaved elaboration: In the elaboration of an application $f a$
        the function term $f$ and the argument term $a$ can be elaborated in
        parallel. A metavariable for the argument $a$ and its type is
        introduced. The elaboration of the function term $f$ can fill the
        argument type and the elaboration of the argument can fill the argument
        and the type.

    \item Wildcard: In the source code a wildcard can be used to ask the
        compiler to fill the wildcard from information it already has.

    \item Constructor arguments in pattern of case expressions:
\end{enumerate}





\paragraph{Instantiation}
%------------------------------------------------------------
Metavariables can be \emph{instantiated} during unification.

Suppose we have
$$
\begin{array}{lllll}
    \Gamma &\vdash& \meta m: \Pi \vec x^{\vec A}. M
    \\
    \Gamma, \Delta & \vdash & \meta m \vec x \le t^T
    \text{ or }
    t^T \le \meta m \vec x
\end{array}
$$
the variables $\vec x$ are pairwise distinct, $t$ does not contain metavariables
and the conditions
$$
\vertlist{
    \FV(t) \subseteq \FV(\Gamma) \cup \set{\vec x}
    \\
    \vec x^{\vec A} \subseteq \Delta
    \\
    \Gamma,\Delta \vdash T \le M
}
$$
are satisfied. In that case we can do the instantiation
$$
\meta m := \lambda \vec x^{\vec A}. t
$$

Why are the conditions necessary?
\begin{enumerate}
    \item $\FV(t) \subseteq \FV(\Gamma) \cup \set{\vec x}$: The metavariable
        $\meta m$ has to be valid in the context $\Gamma$. In the substitution
        term $\lambda \vec x^{\vec A}. t$ the variables $\vec x$ are bound. However
        if $t$ contained more free variables outside of $\Gamma$, then these
        variables are not bound making $\meta m$ invalid in the context
        $\Gamma$.

    \item $\vec x^{\vec A} \subseteq \Delta$ and $\vec x$ are pairwise distinct:
        This guarantees that the variables $\vec x$ can be abstracted over. It
        is possible to permute the variables in $\Delta$ into the form $\vec
        x^{\vec A}, \Delta'$ where $t$ does not contain free variables of
        $\Delta'$.

    \item $\Gamma, \Delta \vdash T \le M$: The instantiation term satisfies
        $\Gamma \vdash \lambda \vec x^{\vec A}. t : \Pi \vec x^{\vec A}. T$.
        Its type has to be a subtype of $\Pi \vec x^{\vec A}. M$.

    \item $t$ does not contain metavariables: This strong condition guarantees
        that metavariables are instantiated bottoms up and there is no
        circularity in the instantiations.
\end{enumerate}





\paragraph{Push to Lower Context} A metavariables lives only in its context and
in higher contexts. It cannot be used in lower contexts. In order to use a
metavariable $\meta m_h$ living in the context $\Gamma, x^A$ in the lower
context $\Gamma$ we have to create a metavariable $\meta m_l$ in the lower
context $\Gamma$ and instantiate $\meta m_h$ by using $\meta m_l$ in the
following manner
$$
\vertlist{
    \Gamma, x^A &\vdash& \meta m_h: M_h
    \\
    \Gamma &\vdash& \meta m_l: \Pi x^A.M_h
    &\text{new meta in lower context}
    \\
    \Gamma, x^A &\vdash& \meta m_l x : M_h
    &\text{welltyped}
    \\
    \meta m_h &:=& \meta m_l x &\text{instantiation}
}
$$


\subsection{Flat Head Normal Forms}
%--------------------------------------------------------------------------------


The following terms are in \emph{flat head normal form}
\begin{enumerate}
    \item Products

    \item Abstractions

    \item Base terms $h \vec a$: The head symbol $h$ is one of
        \begin{enumerate}
            \item Variable or metavariable
            \item Constructor
            \item Inductive type
            \item Stuck case tree application $\cta(*, t, *, p)$
                where the the focal term $p.f$ has not enough information to
                make the decision of the current tree $t$.
        \end{enumerate}


        $x$ is a prime term i.e. either a variable,
        metavariable, constructor or inductive type or $x$ is a case expression
        which cannot be reduced by analyzing its arguments $\vec a$ with the help
        of its case tree.
\end{enumerate}

The following terms are not unifiable:
\begin{enumerate}
    \item Two terms in head normal form of different structure are mutually not
        unifiable except one of them is a base term with a head symbol which has
        a definition.

    \item Two base terms with different constructors, different free variables
        without definition or one of them a constructor and the other a variable
        without definition in the head position.
\end{enumerate}





\subsection{Unify Products}
%--------------------------------------------------------------------------------

$$
    \Gamma \vdash \Pi x^{A_1}. B_1 \le \Pi x^{A_2}. B_2
$$

Requirements to satisfy:
$$
\begin{array}{llll}
    \Gamma &\vdash&
    A_2 \le A_1
    &\text{arguments contravariant}
    \\
    \Gamma, x^{A_2} &\vdash&
    B_1 \le B_2
    &\text{results covariant}
\end{array}
$$
The first requirement has to be satisfied before the second one is checked,
otherwise we have no valid type for the variable $x$ which is valid for both
result types.

Why do we use $A_2$ as the type of $x$? We have the general typing rule
specialized for variables
$$
    \rulev{
        \Gamma \vdash x : T
        \\
        T \le U
    }
    {
        \Gamma \vdash x: U
    }
$$
If a variable has type $T$ which is a subtype of type $U$, then the variable has
type $U$ as well. Therefore in the above requirement for the result type we have
to use the stronger (subtype) of the types $A_1$ and $A_2$.






\subsection{Unify Abstractions}
%--------------------------------------------------------------------------------

Lambda terms are never types. Therefore they have to be equivalent.

$$
    \Gamma \vdash \lambda x^{A_1}. e_1 \equiv \lambda x^{A_2}. e_2
$$

Requirements to satisfy:
$$
\begin{array}{lll}
    \Gamma &\vdash&
    A_1 \equiv A_2
    \\
    \Gamma, x^{A_1} &\vdash&
    e_1 \equiv e_2
\end{array}
$$
The first requirement has to be satisfied before the second one is checked,
otherwise we have no valid type for the variable $x$ which is valid for both
bodies. Since $A_1$ and $A_2$ are equivalent after the first check we can choose
either one as the type for the variable $x$.






\subsection{Unify Base Term with Other Term}
%--------------------------------------------------------------------------------


$$
    \Gamma \vdash h \vec a \le t
$$




\subsection{Unify two Base Terms}
%--------------------------------------------------------------------------------


$$
    \Gamma \vdash h_1 \vec a_1 \le h_2 \vec a_2
$$
