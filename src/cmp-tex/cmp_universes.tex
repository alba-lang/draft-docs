\section{Universes}





\subsection{Basics}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Every term {\tt Any} in the source code is treated as {\tt Any u} where $u$ is a
metavariable representing the universe level of {\tt Any}.

\paragraph{Constraints} Universe levels can be constrained by $u \le v$ or $u <
v$.
\begin{itemize}
    \item Actual $A$ and required $R$ argument types: Constraint $A \le R$. If
        the constraint is $\Any_u \le \Any_v$ then the universe constraint is $u
        \le v$. In case of $\Any_{u + 1} \le \Any_v$ we get $u < v$.

        The second form can appear, if the actual argument is $\Any_u$ which has
        the type $\Any_{u + 1}$.

    \item Constructor argument types: A constructor of an inductive type always
        constructs an object of the inductive type whose sort is either $\Prop$
        or $\Any_v$. The latter one requires that all argument types of the
        constructor live in a sort $s$ which satisfies $s \le \Any_v$.

        For polymorphic constructors i.e. constructors with argument types
        $\Any_u$ living in the universe level $u + 1$ this generates the
        constraint $u < v$.
\end{itemize}

As long as there are no universe annotations in the source code i.e. the only
allowed sorts are $\Prop$ and $\Any$, these are the only constraints which can
appear. However in general constraints of the form
$$
    u + i \le v + j
$$
might appear where $u$ and $v$ are universe variables and $i$ and $j$ are
constants to be added to the variables. In order to be welltyped
$$
    i \ge j
$$
has to be satisfied. I.e. we want the constraint to be stronger than $u \le v$.
Otherwise it is considered a type error. Then the constraint can be normalized
to
$$
    u + (i - j) \le v
$$


If the source code does not have annotations of universe levels then there shall
never be type errors because of level constraints. Reason: All source
expressions {\tt Any} gets its own level variable $u$ and is interpreted as
$\Any_u$. Every type expression gets a required sort $\Any_v$  where $v$ is free
floating upwards.

The constraint can be resolve by putting instantiating all universe variable
which appear only on the left hand side of constraints $u + i \le v$ to zero.
The instantiating all variables recursively on the right hand side which have
only instantiated variable on the left hand side by using the maximum of all $u
+ i$ values.

\paragraph{Universe Polymorphism} All global definitions  can be made universe
polymorphic by adding as a first argument {\tt u: Level} and replacing all terms
$\Any_i$ by $\Any_{u + i}$. This is needed only for definitions where $\Any_i$
appears not only as the result type.

When $\Any_i$ appears only as a result type, it must be $\Any_0$ and therefore
an object of this type can be fed to any universe polymorphic function because
$$
    \Any_0 \le \Any_u
$$
for all possible universe levels $u$.






\subsection{Examples}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Inductive types without type parameters reside at the universe level $0$.

\begin{alba}
    type Unit: Any := ()

    type Bool: Any := [true: _, false: _]

    type Nat:  Any := [zero: _, succ: _ -> _]
\end{alba}
where {\tt Any} in the above examples is interpreted as {\tt Any 0}.

Types with type parameters are universe polymorphic
\begin{alba}
    type List (A: Any): Any := [[]: _, (::): A -> _ -> _]

    -- is interpreted as

    type List {u: Level} (A: Any u): Any u := ...
\end{alba}

All type parameters can live in a arbitrary universe level. The result type
lives at the maximum universe level of its constructors.
\begin{alba}
    []:   List : Any v
    (::): A -> List -> List: Any (max u v)
\end{alba}
This constraint can be satisfied with $u = v$.

Polymorphic constructors require higher universe levels. Examples

\begin{alba}
    -- Example: Existential Type

    abstract type Show (A: Any): Any :=
        show: A -> String

    type T: Any v :=
        make {A: Any u}: A -> Show A -> T

    -- constructor type
    (all {A: Any u}: A -> Show A -> T): Any (max (u + 1) v)

    -- result:
    type T {u}: Any (u + 1) :=
        make {A: Any u}: A -> Show A -> T

\end{alba}
An object of type $T$ can contain an object of any type and its show function.
The universe of the constructor is at least at level $u + 1$. Since the level of
the inductive type is in all constructors (they must construct an object of the
type), this level is irrelevant $v \le v$. However the other level poses a real
constraint $u + 1 \le v$. I.e. the universe level must be higher that an
arbitrary level $u$

\begin{alba}
    -- Example: Heterogeneous Lists

    type HList: List (Any u) -> Any v :=
        []:  HList []

        (::) {T: Any u} {Ts: List (Any u)}: T -> HList Ts -> Hlist (T :: Ts)
        --         |             |          |      |             : Any v
        --         |             |          |      \ : Any v
        --         |             |          \ : Any u
        --         |             \ : Any (u + 1)
        --         \: Any (u + 1)

    -- Result
    u + 1 <= v
\end{alba}




\subsection{Universes and Sorts}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


We have the following sorts or universes (sorts and universes are synonymous):
\begin{enumerate}
\item $\Prop$: Impredicative universe of propositions

\item $\Any_i$: Predicative universes of types for $i \in \set{0, 1, 2, \ldots}$

\item $\Any_\infty$: Top universe
\end{enumerate}
and the builtin type $\Uni$ with the typing judgements which are treated as
axioms:
$$
\begin{array}{l}
    \Uni : \Any_\infty
    \\
    \Prop : \Any_0 : \Any_1 \ldots
\end{array}
$$


All sorts except the top sort $\Any_\infty$ have types. Therefore it is
possible to introduce type variables $X: s$ for all sorts except the top sort.

Furthermore since $\Uni$ has type $\Any_\infty$ it is possible to introduce
universe variables $u: \Uni$.

The type of a type is always a sort. The sort of a type defines the
universe of the type. I.e. all types live in a universe. The typing judgement
$T: s$ says that the type $T$ lives in the universe $s$.


There is a subtle difference between the universe of a type and the universe of
an object. An object has a type and its type lives in a universe. We say the an
\emph{object $o$ lives in a universe $s$ if its type $T$ lives in the universe
$s$}. I.e. the typing judgement $o : T : s$ must be valid. In other words $o$
has type $T$ and $T$ has type $s$.

A type $T$ can be regarded as a type. Then its type is a sort $s$ with $T : s$
and it therefore lives in the universe $s$ as a type.

However a type can be regarded as an object as well. Then there is the typing
judgement $T: s_1 : s_2$. We say the object $T$ lives in the universe $s_2$.

Some examples: The type $\Nat$ lives in the universe $\Any_0$. The object $1$
has type $\Nat$. Therefore the object $1$ lives in the universe $\Any_0$. The
object $\Nat$ has type $\Any_0$ which has the type $\Any_1$. Therefore the
object $\Nat$ lives in the universe $\Any_1$. By the same reasoning the object
$\Any_0$ lives in the universe $\Any_2$.

All types regarded as objects live in a universe higher than the types regarded
as types.




\subsection{Typing Rules}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Typing rules for products:
\begin{enumerate}
    \item Propositional Products:
        $$
            \rulev{
                \Gamma \vdash A: s
                \\
                \Gamma, x^A \vdash B: \Prop
                \\
                A \ne \Uni
            }
            {
                \Gamma \vdash \Pi x^A. B : \Prop
            }
        $$
    \item Predicative Products:
        $$
            \rulev{
                \Gamma \vdash A: \Any_i
                \\
                \Gamma, x^A \vdash B: \Any_i
            }
            {
                \Gamma \vdash \Pi x^A. B : \Any_i
            }
        $$

    \item Universe Products:
        $$
            \rulev{
                \Gamma \vdash u: \Uni
                \\
                \Gamma, u^\Uni \vdash B: s
                \\
                A \ne \Uni
            }
            {
                \Gamma \vdash \Pi u^\Uni. B : \Any_\infty
            }
        $$
\end{enumerate}
These rules guarantee that the type $\Pi u^\Uni. B$ of a universe polymorphic
object cannot be used as an argument to a function.


Furthermore we have the cumulativity rule
$$
\rulev{
    \Gamma \vdash t : T
    \\
    \Gamma \vdash U : s
    \\
    T \le U
}
{
    \Gamma \vdash t : U
}
$$
The cumulativity rule for predicative universes says that whenever $T: \Any_i$
is valid, then $T: \Any_j$ is valid for all $i \le j$ since $\Any_i \le \Any_j$
is valid.  Together with the predicative product rule we get
$$
\rulev{
    \Gamma \vdash A: \Any_i
    \\
    \Gamma, x^A \vdash B: \Any_j
    \\
    i \le k
    \\
    j \le k
}
{
    \Gamma \vdash \Pi x^A.B : \Any_k
}
$$
or maybe more specific
$$
\rulev{
    \Gamma \vdash A: \Any_i
    \\
    \Gamma, x^A \vdash B: \Any_j
}
{
    \Gamma \vdash \Pi x^A.B : \Any_{\text{max}(i,j)}
}
$$






\subsection{Constraints}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Universe variables are always implicit. The programmer usually ommits universe
variables in the source code i.e. instead of $\Any_u$ the source code contains
only $\Any$. The compiler generates for each sort $\Any$ in the source code a
metavariable $\meta u : \Uni$ and interprets the sort $\Any$ as $\Any_{\meta
u}$.

There are the following two sources of constraints between universes.

\begin{enumerate}
    \item Predicative type argument $T: \Any_{u}$: If $T$ is used as an actual
        argument e.g. in the expression $f T$, then the function $f$ must have
        the type $\Pi X^{\Any_v}. R$.  This creates the constraint $u \le v$.

    \item Predicative inductive type $\Pi \vec x^{\vec A}. \Any_{v}$: Any
        instance of such an inductive type lives in the universe $\Any_{v}$.

        This requires that all arguments of all contructors must not live in a
        higher universe. Reason: Pattern matches of an indutive type living in
        the universe $\Any_{v}$ must not uncover any object living in a
        higher universe. In other words: \emph{Only smaller (or equal) things
        can be used to create greater things}.

        I.e. any constructor argument living as an object in the universe
        $\Any_u$ creates the constraint $u \le v$.
\end{enumerate}






\subsection{Predicative Inductive Types}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In Alba new types can be created as inductive types. The simplest inductive
types have neither parameter nor index arguments.
$$
\begin{array}{lll}
    B &:=& [T^{\Any_0} \mid T, T]
    \\
    N &:=& [T^{\Any_0} \mid N, N \to N]
\end{array}
$$

The types of booleans and natural numbers live in the universe $\Any_0$ because
of the typing judgements $B: \Any_0$ and $N: \Any_0$. Objects of type boolean do
not contain anything. Objects of type $N$ might contain other natural numbers
(second constructor). There is no possibility for such simple types to contain
objects living in a higher universe than $\Any_0$.

Polymorphic types like lists and pairs have type parameters. The type parameters
can live in any universe. Therefore they need an universe level parameter and a
type parameter whhich depents on the uinverse level.

$$
\begin{array}{lllll}
    L &:=& [i^\Uni, A^{\Any_i} &\mid T^{\Any_i} &\mid T, A \to T \to T]
    \\
    P &:=& [i^\Uni, A^{\Any_i}, B^{\Any_i} &\mid T^{\Any_i} &\mid A \to B \to T]
\end{array}
$$

\begin{alba}
    type List {u: Univ} (A: Any u): Any u :=
        []: List

        (::): A -> List -> List
\end{alba}



Having that we can construct a list of natural numbers $L\,0\,N: \Any_0$ living
in the universe level $0$. However it is possible to construct list of types
$L\,(i+1)\,\Any_i$ which might live in the universe level $i$. The types as
types live in the universe level $i$, but the types as objects live in the
universe level $i+1$. Therefore the whole list which contains objects from the
universe level $i + 1$ lives in the universe level $i+1$ as well.


A more complex type is the dependent list.
$$
\begin{array}{lllll}
    \text{DL} &:=&
    [
        i^\Uni, A^{\Any_i}, P^{A \to \Any_i}
        &\mid
        T^{LiA \to \Any_i}
        &\mid
        T[],
        \Pi a^A \text{as}^{LiA}.
            Pa \to T\text{as} \to T(a :: \text{as})
    ]
\end{array}
$$

\begin{alba}
    type DL {u: Univ} {A: Any u} (P: A -> Any i): List A -> Any i :=
        [] : DL []

        (::) {x: A} {xs: List A}: P x -> DL xs -> DL (x :: xs)
\end{alba}

A dependent list might contain objects of type $A$, $LiA$, $Pa$ and
$T\text{as}$. All these object live in the universe level $i$. Therefore the
whole dependent list can live in the universe level $i$.

Furthermore we can construct hetergeneous lists.
$$
\begin{array}{lllll}
    \text{HL} &:=&
    [
        i^\Uni
        &\mid
        T^{L(i+1)\Any_i \to \Any_{i+1}}
        &\mid
        T[],
        \Pi A^{\Any_i} \text{As}^{L(i+1)\Any_i}.
            A \to T\text{As} \to T(A :: \text{As})
    ]
\end{array}
$$

\begin{alba}
    type HL {u: Univ}: List {u + 1} (Any u) -> Any (u + 1) :=
        [] : HL []

        (::) {T: Any u} {Ts: List {u + 1} (Any u)}:
            T -> HL Ts -> HL (T :: Ts)
\end{alba}



A heterogeneous list contains objects $A$ and $\text{As}$ with the typing
judgements $A : \Any_i : \Any_{i+1}$, $\text{As}: L(i+1)\Any_i : \Any_{i+1}$.
These objects live in the universe level $i+1$. Therefore the whole
heterogeneous list object must live in the universe level $i+1$ as well.


Here is a rather strange type
$$
\begin{array}{lllll}
    \text{Ex}
    &:=&
    [
        i^\Uni,
        P^{\Any_i \to \Prop}
        &\mid
        T^{\Any_{i+1}}
        &\mid
        \Pi X^{\Any_i}. P X \to T
    ]
\end{array}
$$

\begin{alba}
    type Ex {u} (P: Any u -> Prop): Any (u + 1) :=
        ex {X: Any u}: P X -> Ex
\end{alba}




\subsection{No Universe Polymorphism}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

No universe polymorphis means that all user entered $\Any$ are interpreted as
$\Any_0$. Therefore all types live as types at the universe level $0$ and all
objects which are not types live as well at the universe level $0$. Types as
objects live at the universe level $1$.

This has an important consequence: \emph{Type objects cannot be contained within
other objects}. There is no list of types, no pair of types etc.

Of the above examples nearly all types are possible without universe
polymorphism. Only heterogeneous lists $\text{HL}$ and the strange type
$\text{Ex}$ are not possible without universe polymorphism.

Without universe polymorphism we are basically in the calculus of constructions
with inductive types. All constructions which require an infinite set of
stratified universes with cumulativity are not possible.





\subsection{Existential Types}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Without universe polymorphism existential types are not possible.
This can be show by using an example from Peyton Jones:

\begin{alba}
    abstract type Show (A: Any): Any :=
        show: A -> String

    type T: Any :=
        make {A: Any} {_: Show A}: A -> T
\end{alba}

If all {\tt Any}s were at the same level we would have
\begin{alba}
    type T {u}: Any u :=
        make {A: Any u} {_: Show A}: A -> T

    -- with the following type levels
    T:                                      Any u
    (all {A: Any u} {_: Show A}: A -> T):   Any (u + 1)

    -- because of
    Any u: Any (u + 1)
\end{alba}
%
This is not welltyped, because the constructor type lives in a higher universe
than the inductive type.

We have to put the inductive type one level up in order to become a valid
definition.

\begin{alba}
    type T {u} : Any (u + 1) :=
        make {A: Any u} {_: Show A}: A -> T
\end{alba}
