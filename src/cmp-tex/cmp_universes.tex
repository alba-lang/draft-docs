\section{Universes}





\subsection{Universes and Sorts}


We have the following sorts or universes (sorts and universes are synonymous):
\begin{enumerate}
\item $\Prop$: Impredicative universe of propositions

\item $\Any_i$: Predicative universes of types for $i \in \set{0, 1, 2, \ldots}$

\item $\Any_\infty$: Top universe
\end{enumerate}
and the builtin type $\Uni$ with the typing judgements which are treated as
axioms:
$$
\begin{array}{l}
    \Uni : \Any_\infty
    \\
    \Prop : \Any_0 : \Any_1 \ldots
\end{array}
$$


All sorts except the top sort $\Any_\infty$ have types. Therefore it is
possible to introduce type variables $X: s$ for all sorts except the top sort.

Furthermore since $\Uni$ has type $\Any_\infty$ it is possible to introduce
universe variables $u: \Uni$.

The type of a type is always a sort. The sort of a type defines the
universe of the type. I.e. all types live in a universe. The typing judgement
$T: s$ says that the type $T$ lives in the universe $s$.


There is a subtle difference between the universe of a type and the universe of
an object. An object has a type and its type lives in a universe. We say the an
\emph{object $o$ lives in a universe $s$ if its type $T$ lives in the universe
$s$}. I.e. the typing judgement $o : T : s$ must be valid. In other words $o$
has type $T$ and $T$ has type $s$.

A type $T$ can be regarded as a type. Then its type is a sort $s$ with $T : s$
and it therefore lives in the universe $s$ as a type.

However a type can be regarded as an object as well. Then there is the typing
judgement $T: s_1 : s_2$. We say the object $T$ lives in the universe $s_2$.

Some examples: The type $\Nat$ lives in the universe $\Any_0$. The object $1$
has type $\Nat$. Therefore the object $1$ lives in the universe $\Any_0$. The
object $\Nat$ has type $\Any_0$ which has the type $\Any_1$. Therefore the
object $\Nat$ lives in the universe $\Any_1$. By the same reasoning the object
$\Any_0$ lives in the universe $\Any_2$.

All types regarded as objects live in a universe higher than the types regarded
as types.




\subsection{Typing Rules}


Typing rules for products:
\begin{enumerate}
    \item Propositional Products:
        $$
            \rulev{
                \Gamma \vdash A: s
                \\
                \Gamma, x^A \vdash B: \Prop
                \\
                A \ne \Uni
            }
            {
                \Gamma \vdash \Pi x^A. B : \Prop
            }
        $$
    \item Predicative Products:
        $$
            \rulev{
                \Gamma \vdash A: \Any_i
                \\
                \Gamma, x^A \vdash B: \Any_i
            }
            {
                \Gamma \vdash \Pi x^A. B : \Any_i
            }
        $$

    \item Universe Products:
        $$
            \rulev{
                \Gamma \vdash u: \Uni
                \\
                \Gamma, u^\Uni \vdash B: s
                \\
                A \ne \Uni
            }
            {
                \Gamma \vdash \Pi u^\Uni. B : \Any_\infty
            }
        $$
\end{enumerate}
These rules guarantee that the type $\Pi u^\Uni. B$ of a universe polymorphic
object cannot be used as an argument to a function.


Furthermore we have the cumulativity rule
$$
\rulev{
    \Gamma \vdash t : T
    \\
    \Gamma \vdash U : s
    \\
    T \le U
}
{
    \Gamma \vdash t : U
}
$$
The cumulativity rule for predicative universes says that whenever $T: \Any_i$
is valid, then $T: \Any_j$ is valid for all $i \le j$ since $\Any_i \le \Any_j$
is valid.  Together with the predicative product rule we get
$$
\rulev{
    \Gamma \vdash A: \Any_i
    \\
    \Gamma, x^A \vdash B: \Any_j
    \\
    i \le k
    \\
    j \le k
}
{
    \Gamma \vdash \Pi x^A.B : \Any_k
}
$$
or maybe more specific
$$
\rulev{
    \Gamma \vdash A: \Any_i
    \\
    \Gamma, x^A \vdash B: \Any_j
}
{
    \Gamma \vdash \Pi x^A.B : \Any_{\text{max}(i,j)}
}
$$






\subsection{Constraints}


Universe variables are always implicit. The programmer usually ommits universe
variables in the source code i.e. instead of $\Any_u$ the source code contains
only $\Any$. The compiler generates for each sort $\Any$ in the source code a
metavariable $\meta u : \Uni$ and interprets the sort $\Any$ as $\Any_{\meta
u}$.

There are the following two sources of constraints between universes.

\begin{enumerate}
    \item Predicative type argument $T: \Any_{u}$: If $T$ is used as an actual
        argument e.g. in the expression $f T$, then the function $f$ must have
        the type $\Pi X^{\Any_v}. R$.  This creates the constraint $u \le v$.

    \item Predicative inductive type $\Pi \vec x^{\vec A}. \Any_{v}$: Any
        instance of such an inductive type lives in the universe $\Any_{v}$.

        This requires that all arguments of all contructors must not live in a
        higher universe. Reason: Pattern matches of an indutive type living in
        the universe $\Any_{v}$ must not uncover any object living in a
        higher universe. In other words: \emph{Only smaller (or equal) things
        can be used to create greater things}.

        I.e. any constructor argument living as an object in the universe
        $\Any_u$ creates the constraint $u \le v$.
\end{enumerate}
