\section{Elaboration}
%--------------------------------------------------------------------------------


\begin{comment}
    Proof carrying elaboration
    ------------------------------------------------------------

    An elaboration context consists of
    - Set of modules
    - Set of contexts
        - bound variables with types
        - set of metavariables with types
        - set of constructed terms with types in this context
        - set of subtype or equivalence pairs

    A term is a pair (context-id, term number) or an axiomatic term.

    Axiomatic terms: Prop, Any u, Uni. Axiomatic terms don't need a context.
    They are welltyped and wellformed by axiom.

    Gamma |- t1: T1, t2, T2, ....
\end{comment}




\subsection{Contexts}
%--------------------------------------------------------------------------------


\subsection{Term Elaboration}
%--------------------------------------------------------------------------------


\paragraph{Basics}

The parser returns expressions as an abstract syntax tree. The term elaborator
has to transform the ast into a  term. The elaborator has to elaborate all
subtrees of the ast. Sometimes the elaboration of an ast term can get stuck e.g.
\begin{itemize}
    \item An ambiguous name cannot be resolved because the result type or the
        type of some arguments are not known.

    \item A unification constraint $\meta m \vec a \sim e$ cannot be resolved
        because the arguments $\vec a$ for the metavariable $\meta m$ are not
        only local variables. If the arguments are only variables the constraint
        has the resolution $\meta m := \lambda \vec x. e$ provided that the term
        $e$ has not more local variables than $\vec x$.

    \item $\ldots$
\end{itemize}

The elaboration for a stuck ast term can be resumed as soon as the condition for
the stuckness has been resolved.

A stuck elaboration can be continued if the elaboration tries to elaborate
another ast which might resolve the some stuckness condition. The are many terms
which can be elaborated in different orders.

\begin{itemize}
    \item The elaboration of an application $f \vec a$ can elaborate the
        function term and the arguments in any order.

    \item The elaboration of a let expression can elaborate the local
        definitions and the body in any order.

    \item $\ldots$
\end{itemize}

An elaboration fails if it has subterms of the ast which are stuck and it has
exploited all possibilities to elaborate other subterms before the stuck
subterms.


\paragraph{Algorithm}

\begin{description}
\item [Elaborate subterms]

    Repeatedly choose any subterm which is not stuck and elaborate it.

    This procedure ends with all subterms elaborated or with some stuck subterms
    where each stuck subterm has some constraints which have the be resolved
    before it can resume elaboration and a procedure which can be started on
    resolved constraints.

\item [Elaborate term]
    If all subterms are elaborated then elaborate the complete term.

    If the elaboration of some subterms is stuck, then the elaboration of the
    term is stuck as well. It merges the stuckness conditions of its stuck
    subterms to its own stuckness conditions and generated a resumption
    procedure.
\end{description}



\paragraph{Stuckness Conditions}

\begin{enumerate}
    \item
        An atomic stuckness condition is a constraint.

    \item An resumption point is a nonempty set of constraints and a
        resumption procedure which can be called if all constraints in the set
        have been resolved.

    \item A stuckness condition is a nonempty set of resumption points.
\end{enumerate}






\subsection{Metavariables}
%--------------------------------------------------------------------------------

Reasons to introduce metavariables:
\begin{enumerate}

    \item Untyped binders e.g. terms of the form $\lambda x. e$ or $\Pi x. R$
        where the type of the bound variable $x$ is not present in the source
        code.

    \item Nonpresent implicit arguments in applications $f \vec a$: The type of
        $f$ has implicit arguments which are not present in the list of actual
        arguments $\vec a$.
\end{enumerate}




\subsection{Unification}
%--------------------------------------------------------------------------------


\paragraph{Basics}

In an application $f \vec a$ the types of the actual arguments $\vec a$ to the
corresponding types of the formal arguments. I.e.
$$
    T_\text{actual} \le T_\text{formal}
$$
must be valid. This constraint can be checked by transforming both types into
their normal forms an verify it on the normal forms.

The normal form of a type is $\Pi \fargs x A. s$, $\Pi \fargs x A. T \vec
a$ or $\Pi \fargs x A . I \vec q \vec a$ where $s$ is a sort, $T$ is some global
function without definition available and $I$ is some inductive type. The first
form allows subtyping by $s_\text{actual} \le s_\text{formal}$. The second one
does not allow subtyping and the third allows subtyping as defined for inductive
type (the type with more alternatives and viewer fields is a supertype).

I.e. the above constraint usually generates subconstraints of the form
$$
    a \sim b
$$
either because the compared subexpressions are not types or appear in argument
positions.

In order to verify the typing constraint $T \le U$ it is necessary to visit both
terms in parallel by converting corresponding subterms into their normal form.

Constraints usually contain metavariables. Unification is the process to
instantiate metavariables such that the terms on both sides satisfy the
constraint.






\paragraph{Possible Performance Problem}
%--------------------------------------------------------------------------
There is one sublety where performance might be affected. If we want to verify
the constraint
$$
    f \vec a \sim f \vec b
$$
where the definition of $f$ is available (or $f$ is simply an abstraction). The
function $f$ might throw away some of its arguments or multiply the occurrences
of some of its arguments. In the first szenario it would be better to first do
the head reduction and then continue with the processing. In the second szenario
it would be better first to verify the constraint on the corresponding arguments
and not do the reduction. The situation might be more complex because some
arguments might be thrown away and some other arguments duplicated heavily.

It is desirable to find a way to trace the constraints and recognize duplicates
to avoid verifying the same constraints over and over again.






\paragraph{Classification of Constraints}
%--------------------------------------------------------------------------

\begin{enumerate}
    \item Undedidable:
        $$
            f \vec a \sim t
        $$
        where $f$ is a global function where its definition is not available and
        $t \ne f \vec b \ldots$.
        I.e. the terms might be unifiable if the definition
        was available and expanded. However it cannot be verified.

    \item Metavariable Instantiation:
        $$
        \rulev{
            \meta m \vec x \sim e
            \\
            \vec x \text{ pairwise disjoint free variables}
            \\
            \FV(e) \subseteq \vec x
        }
        {
            \meta m := \lambda \fargs x A. e
        }
        $$
        With this instantiation $\meta m \vec x = (\lambda \fargs x A .e) \vec
        x$ reduces to $e$ satisfying the constraint.

    \item Unsatisfiable by Structure: Let $t$ and $u$ be in head normal form.
        The following structures for $t$ and $u$ are mutually incompatible for
        unification
        $$
        \begin{array}{l}
            \lambda \fargs x A. e
            \\
            \Pi \fargs x A. B
            \\
            x \vec a
            \\
            \make^I_\ell \vec a
            \\
            \case(f^F , \vec c)
            \\
            \type(\Gamma , T^K , \vec C)
        \end{array}
        $$
        where $x$ is a free variable. Reason: No instantiation of metavariables
        can change the structure of these terms.

    \item Unsatisfiable by Discriminator:
        $$
        \begin{array}{lll}
            x \vec a &\sim& y \vec b
            \\
            \make^I_{\ell_1} \vec a &\sim& \make^I_{\ell_2} \vec b
        \end{array}
        $$
\end{enumerate}








\subsection{Constants}
%---------------------------------------------------------------------------

The following types can have constants:
\begin{itemize}
    \item Natural numbers and integral numbers ({\tt Nat, Int})
    \item Floating point numbers ({\tt Float})
    \item Machine numbers (like {\tt U8, U16, U32, U64, ...})
    \item Characters
    \item Strings
\end{itemize}

With characters and strings there is no ambiguity. However the number {\tt 100}
appearing in the source code is ambiguous. It can be an inhabitant of different
types (practically all number types). Therefore we need a required type to fill
a hole with the constant {\tt 100}. Without a required type the elaborator is
stuck waiting for the required type.

The elaboration of constants is straightforward. Resolve ambiguities based on
the requirement for the hole. If unresolvable then get stuck on the requirement.
If ambibuities can be resolved then check the required type and in case of
success put the constant into the hole.








\subsection{Names}
%---------------------------------------------------------------------------

Names can be ambiguous. They can point to global of local symbols. In
order to resolve ambiguities the elaborator compares the required signature of
the hole with the signature of the symbol. Note that types in head normal form
look like
$$
\begin{array}{l}
    \Pi \fargs x A. T \vec a
    \\
    \Pi \fargs x A. s
\end{array}
$$

A signature of a type with $n$ arguments is an array of length $n+1$ where the
first $n$ elements represent the argument types and the last element represents
the result type. The entries are
\begin{itemize}
    \item {\tt G}: Reference to a global symbol which is the head symbol of the
        type.
    \item {\tt L}: Reference to a local symbol which is the head symbol of the
        type.
    \item {\tt U}: Unknown
    \item {\tt I}: Implicit Argument
    \item {\tt S}: Sort
\end{itemize}
%
%
Examples:
\begin{alba}
    (+): Nat -> Nat -> Nat
            [Nat, Nat, Nat]

    (=): all {A: Any}: A -> A -> Prop
            [I, U, U, S]

    length: all {A: Any}: List A -> Nat
            [I, List, Nat]

    identity: all {A: Any}: A -> A
            [I, U, U]

    (|>): all {A: Any} {P: A -> Any} (a: A) (f: all x: P x): P a
            [I, I, U, U, U]

    Absurd: all {A: Any}: A
            [U, U]
\end{alba}
%
If the signature of the hole and the signature of the symbol resolve the
ambiguity then the symbol can be put into the hole (checking the type before).
If the ambiguity cannot be resolved then the elaborator gets stuck on the hole.

It has to be guaranteed that ambiguous names must be resolvable by their
signature.








\subsection{Applications $f \vec a$}
%---------------------------------------------------------------------------



\paragraph{Example}
%------------------------------------------------------------
Elaborate the term
\begin{alba}
    (|>) 1 (+) 2: Nat

    -- equivalent to
    (1 |> (+)) 2: Nat

    -- in global context
    (+): Nat -> Nat -> Nat
    (+): String -> String -> String)

    (|>) {A: Any} {P: A -> Any} (a: A) (f: all x: P x): P a
    :=
        f a
\end{alba}

The function term in the application must accept 3 explicit arguments and return
an $N$. The global function $\triangleright$ returns an object of type $P a$ if
applied to two arguments. $P a$ might be a function accepting the 3rd explicit
argument. With the metavariables $A$, $P$, $a$ and $f$ it can elaborate the
subterm
$$
(\triangleright) A P a f: P a
$$
The elaborator cannot generate a metavariable for the third argument because it
cannot extract an argument type from $P a$. The elaboration is stuck on the
metavariable $P$.

Now it can try to elaborate the arguments. Argument $1: A$ gets stuck on $A$
because it has to know the number type.

Next it tries $(+): \Pi x^A. P x$ with the information that $P a$ must be a
function type accepting one more explicit argument an return an $N$. With this
information it resolves the ambiguity and generate the constraint
$$
    N \to N \to N \le \Pi x^A. P x
$$
with the resolution $A := N, P := \lambda x^N. N \to N$.

From now on it can build $1: N$, $2: N$ and $(\triangleright) A P f b: N$ with
the metavariable $b: N$ in any order.
