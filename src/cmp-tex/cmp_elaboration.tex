\section{Elaboration}
%--------------------------------------------------------------------------------

\subsection{Contexts}
%--------------------------------------------------------------------------------


\subsection{Term Elaboration}
%--------------------------------------------------------------------------------


\paragraph{Basics}

The parser returns expressions as an abstract syntax tree. The term elaborator
has to transform the ast into a  term. The elaborator has to elaborate all
subtrees of the ast. Sometimes the elaboration of an ast term can get stuck e.g.
\begin{itemize}
    \item An ambiguous name cannot be resolved because the result type or the
        type of some arguments are not known.

    \item A unification constraint $\meta m \vec a \sim e$ cannot be resolved
        because the arguments $\vec a$ for the metavariable $\meta m$ are not
        only local variables. If the arguments are only variables the constraint
        has the resolution $\meta m := \lambda \vec x. e$ provided that the term
        $e$ has not more local variables than $\vec x$.

    \item $\ldots$
\end{itemize}

The elaboration for a stuck ast term can be resumed as soon as the condition for
the stuckness has been resolved.

A stuck elaboration can be continued if the elaboration tries to elaborate
another ast which might resolve the some stuckness condition. The are many terms
which can be elaborated in different orders.

\begin{itemize}
    \item The elaboration of an application $f \vec a$ can elaborate the
        function term and the arguments in any order.

    \item The elaboration of a let expression can elaborate the local
        definitions and the body in any order.

    \item $\ldots$
\end{itemize}

An elaboration fails if it has subterms of the ast which are stuck and it has
exploited all possibilities to elaborate other subterms before the stuck
subterms.


\paragraph{Algorithm}

\begin{description}
\item [Elaborate subterms]

    Repeatedly choose any subterm which is not stuck and elaborate it.

    This procedure ends with all subterms elaborated or with some stuck subterms
    where each stuck subterm has some constraints which have the be resolved
    before it can resume elaboration and a procedure which can be started on
    resolved constraints.

\item [Elaborate term]
    If all subterms are elaborated then elaborate the complete term.

    If the elaboration of some subterms is stuck, then the elaboration of the
    term is stuck as well. It merges the stuckness conditions of its stuck
    subterms to its own stuckness conditions and generated a resumption
    procedure.
\end{description}



\paragraph{Stuckness Conditions}

\begin{enumerate}
    \item
        An atomic stuckness condition is a constraint.

    \item An resumption point is a nonempty set of constraints and a
        resumption procedure which can be called if all constraints in the set
        have been resolved.

    \item A stuckness condition is a nonempty set of resumption points.
\end{enumerate}






\subsection{Metavariables}
%--------------------------------------------------------------------------------

Reasons to introduce metavariables:
\begin{enumerate}

    \item Untyped binders e.g. terms of the form $\lambda x. e$ or $\Pi x. R$
        where the type of the bound variable $x$ is not present in the source
        code.

    \item Nonpresent implicit arguments in applications $f \vec a$: The type of
        $f$ has implicit arguments which are not present in the list of actual
        arguments $\vec a$.
\end{enumerate}




\subsection{Unification}
%--------------------------------------------------------------------------------


\paragraph{Basics}

In an application $f \vec a$ the types of the actual arguments $\vec a$ to the
corresponding types of the formal arguments. I.e.
$$
    T_\text{actual} \le T_\text{formal}
$$
must be valid. This constraint can be checked by transforming both types into
their normal forms an verify it on the normal forms.

The normal form of a type is $\Pi \fargs x A. s$, $\Pi \fargs x A. T \vec
a$ or $\Pi \fargs x A . I \vec q \vec a$ where $s$ is a sort, $T$ is some global
function without definition available and $I$ is some inductive type. The first
form allows subtyping by $s_\text{actual} \le s_\text{formal}$. The second one
does not allow subtyping and the third allows subtyping as defined for inductive
type (the type with more alternatives and viewer fields is a supertype).

I.e. the above constraint usually generates subconstraints of the form
$$
    a \sim b
$$
either because the compared subexpressions are not types or appear in argument
positions.

In order to verify the typing constraint $T \le U$ it is necessary to visit both
terms in parallel by converting corresponding subterms into their normal form.

Constraints usually contain metavariables. Unification is the process to
instantiate metavariables such that the terms on both sides satisfy the
constraint.






\paragraph{Possible Performance Problem}
%--------------------------------------------------------------------------
There is one sublety where performance might be affected. If we want to verify
the constraint
$$
    f \vec a \sim f \vec b
$$
where the definition of $f$ is available (or $f$ is simply an abstraction). The
function $f$ might throw away some of its arguments or multiply the occurrences
of some of its arguments. In the first szenario it would be better to first do
the head reduction and then continue with the processing. In the second szenario
it would be better first to verify the constraint on the corresponding arguments
and not do the reduction. The situation might be more complex because some
arguments might be thrown away and some other arguments duplicated heavily.

It is desirable to find a way to trace the constraints and recognize duplicates
to avoid verifying the same constraints over and over again.






\paragraph{Classification of Constraints}
%--------------------------------------------------------------------------

\begin{enumerate}
    \item Undedidable:
        $$
            f \vec a \sim t
        $$
        where $f$ is a global function where its definition is not available and
        $t \ne f \vec b \ldots$.
        I.e. the terms might be unifiable if the definition
        was available and expanded. However it cannot be verified.

    \item Metavariable Instantiation:
        $$
        \rulev{
            \meta m \vec x \sim e
            \\
            \vec x \text{ pairwise disjoint free variables}
            \\
            \FV(e) \subseteq \vec x
        }
        {
            \meta m := \lambda \fargs x A. e
        }
        $$
        With this instantiation $\meta m \vec x = (\lambda \fargs x A .e) \vec x$
        reduces to $e$ satisfying the constraint.

    \item Unsatisfiable by Structure: Let $t$ and $u$ be in head normal form.
        The following structures for $t$ and $u$ are mutually incompatible for
        unification
        $$
        \begin{array}{l}
            \lambda \fargs x A. e
            \\
            \Pi \fargs x A. B
            \\
            x \vec a
            \\
            \make^I_\ell \vec a
            \\
            \case(f^F , \vec c)
            \\
            \type(\Gamma , T^K , \vec C)
        \end{array}
        $$
        where $x$ is a free variable. Reason: No instantiation of metavariables
        can change the structure of these terms.

    \item Unsatisfiable by Discriminator:
        $$
        \begin{array}{lll}
            x \vec a &\sim& y \vec b
            \\
            \make^I_{\ell_1} \vec a &\sim& \make^I_{\ell_2} \vec b
        \end{array}
        $$
\end{enumerate}
