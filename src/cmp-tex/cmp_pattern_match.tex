\section{Pattern Match}
%----------------------------------------------------------------------


\subsection{Basics}
%----------------------------------------------------------------------

Fully elaborated pattern match expression:
$$
\case[ f^F \mid c_1,  \ldots, c_n]
$$
%
where $F$ is a function type of the form
%
$$
\Pi x_1^{A_1} \ldots x_k^{A_k}. R
$$
%
and where each clause $c_i$ has the form
%
$$
    [\Delta_1. p_1^{P_1}, \ldots, \Delta_m. p_m^{P_m}] := e^E
$$
where the context $\Delta_i$ contains all pattern variables introduced in the
pattern $p_i$
and $P_i$ is the corresponding type of the pattern, $e$ is the body of the
clause and $E$ its corresponding type.

Each clause defines the function
$$
\lambda \Delta_1 \ldots \Delta_m. e^E
$$


The patterns are terms generated from the grammar
$$
    p ::= x \mid x := c \mid x := \make^I_i \vec q p p
$$
where $c$ ranges over constants (strings, characters, numbers, etc.), $x$ ranges
over variables and $p$ ranges over pattern. The expression $\make^I_i \vec q p p
\ldots$ is the $i$th constructor of the inductive type $I$ applied to its
parameter arguments and to its arguments.

Patterns are trees. Each node of the tree is labelled by a pattern variable and
either by a constant or a constructor $\make^I_i \vec q$. A pattern clause has a
sequence of trees.



\subsection{Welltyped}
%------------------------------------------------------------

A clause of the pattern match expression is welltyped if
$$
\begin{array}{lll}
    \Delta_1,\ldots,\Delta_i &\vdash& p_i : P_i
    \\
    \Delta_1,\ldots,\Delta_m &\vdash& e : E
\end{array}
$$
%
and
%
$$
\begin{array}{lll}
    P_i &\le& F[p_1,\ldots,p_i / .]
    \\
    E   &\le& F[p_1,\ldots,p_m / .]
\end{array}
$$
%
where
%
$$
    (\Pi x_1^{A_1} \ldots x_i^{A_i} . R)[p_1,\ldots,p_i/.]
    :=
    R[p_1,\ldots,p_i / x_1,\ldots,x_i]
$$




\subsection{Exhaustiveness and Redundancy}
%------------------------------------------------------------

\emph{Focal point}
Each pattern in a pattern clause can be regarded as a focal
point. At the focal point we have either a variable, a constructor pattern or a
constant. The focal point of two consecutive clauses is the first pattern where
both clauses have a different pattern (we do not regard $p$ and $x:=p$ as
different).

If two consecutive clauses don't have a focal point, then the second one is
redundant which is regarded as an error (the clause is unreachable).








\subsection{Application of a pattern match expression}

An application of a pattern match expression (whose type is always a function
type) has the form
$$
(\case \ldots) \vec a
$$
where $\vec a = [a_1, \ldots, a_n]$ are the arguments to which the pattern match
function is applied. The maximal number of arguments is determined by the type
$F$ of the pattern match expression.

The application can be evaluated if it is possible to find a clause of the
pattern match expression and split the arguments $\vec a$ into subexpressions
$\vec s$ and evaluate $(\lambda \Delta. e^E) \vec s$.




\subsection{Draft}
%----------------------------------------------------------------------

Example of a pattern match expression with all implicit arguments explicitly
stated.

\begin{alba}
    type Vector (A: Any): Nat -> Any :=
        nil: Vector zero
        cons {n: Nat}: A -> Vector n -> Vector (succ n)

    zip {A B: Any}
    : all {n}: Vector A n -> Vector B n -> Vector (A,B) n
    := case
        [{zero}, nil {A}, nil {B}] := nil {(A,B)}

        [{succ n}, cons {A} {n} x xs, cons {B} {n} y xs] :=
            cons {(A,B)} {n} (x,y) (zip {A} {B} {n} xs ys)

    -- without implicit arguments
    := case
        [[], []]           := []

        [x :: xs, y :: ys] := (x, y) :: (zip xs ys)

    -- as case tree
    case
        nil :=
            case nil :=
                nil
        x :: xs :=
            case y :: ys :=
                (x,y) :: zip xs ys
\end{alba}


\begin{alba}
    type Nat := [zero, succ: Nat -> Nat]

    (<=?): Nat -> Nat -> Nat := case
        [zero, _]        :=  true
        [succ _, zero]   :=  false
        [succ n, succ m] :=  n <=? m

    -- as case tree:
    case
        zero           :=   \ _ := true
        succ n :=
            case
                zero   :=   false
                succ m :=   n <=? m
\end{alba}
