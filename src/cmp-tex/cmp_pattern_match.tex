\section{Pattern Match}
%----------------------------------------------------------------------


\subsection{Basics}
%----------------------------------------------------------------------

Fully elaborated pattern match expression:
$$
\case[ f^F \mid c_1,  \ldots, c_n]
$$
%
where $F$ is a function type of the form
%
$$
\Pi x_1^{A_1} \ldots x_k^{A_k}. R
$$
%
and where each clause $c_i$ has the form
%
$$
    [\Delta_1. p_1^{P_1}, \ldots, \Delta_m. p_m^{P_m}] := e^E
$$
where the context $\Delta_i$ contains all pattern variables introduced in the
pattern $p_i$
and $P_i$ is the corresponding type of the pattern, $e$ is the body of the
clause and $E$ its corresponding type.

Each clause defines the function
$$
\lambda \Delta_1 \ldots \Delta_m. e^E
$$


The patterns are terms generated from the grammar
$$
    p ::= x \mid x := c \mid x := \make^I_i \vec q p p
$$
where $c$ ranges over constants (strings, characters, numbers, etc.), $x$ ranges
over variables and $p$ ranges over pattern. The expression $\make^I_i \vec q p p
\ldots$ is the $i$th constructor of the inductive type $I$ applied to its
parameter arguments and to its arguments.

Patterns are trees. Each node of the tree is labelled by a pattern variable and
either by a constant or a constructor $\make^I_i \vec q$. A pattern clause has a
sequence of trees.



\subsection{Welltyped}
%------------------------------------------------------------

A clause of the pattern match expression is welltyped if
$$
\begin{array}{lll}
    \Delta_1,\ldots,\Delta_i &\vdash& p_i : P_i
    \\
    \Delta_1,\ldots,\Delta_m &\vdash& e : E
\end{array}
$$
%
and
%
$$
\begin{array}{lll}
    P_i &\le& F[p_1,\ldots,p_i / .]
    \\
    E   &\le& F[p_1,\ldots,p_m / .]
\end{array}
$$
%
where
%
$$
    (\Pi x_1^{A_1} \ldots x_i^{A_i} . R)[p_1,\ldots,p_i/.]
    :=
    R[p_1,\ldots,p_i / x_1,\ldots,x_i]
$$




\subsection{Case Tree}
%------------------------------------------------------------


Defined by the grammar

$$
    \begin{array}{lllll}
        t
        &::=& e
        %
        \\
        &\mid& [x \mid t]
        %
        \\
        &\mid& [x \mid c_1 t_1, \ldots,  c_n t_n \mid d]
        %
        \\
        &\mid& [x \mid \ell_1 t_1, \ldots, \ell_n t_n \mid d]
    \end{array}
$$
%
where $n > 0$ and
%
\begin{center}
    \begin{tabular}{l p{8cm}}
        $t$ & case tree
        \\
        $d$ & optional case tree (default or catch all)
        \\
        $e$ & expression on the right hand side of a case clause
        \\
        $x$ & pattern variable
        \\
        $c$ & constant
        \\
        $\ell$ & label of a constructor
    \end{tabular}
\end{center}

\paragraph{Exhaustiveness of inner nodes}
%
\begin{center}
    \begin{tabular}{l p{6cm}}
        $[x \mid t]$ & always exhaustive
        %
        \\
        $[x \mid c_1 t_1, \ldots, c_n t_n \mid d]$
        & exhaustive if it has a default tree
        %
        \\
        $[x \mid \ell_1 t_1, \ldots, \ell_n t_n \mid d]$
        & exhaustive if all constructors labels are present which can construct
        an object of the type of $x$ or if it has a default tree
    \end{tabular}
\end{center}


An empty case tree is possible if at least one of the types is not inhabited,
i.e. one of $F[x_1, \ldots, x_i/.]$ of the form $I \vec p \vec a$  where $x_j$
are pattern variables, $\vec p$ are parameter arguments and $\vec a$ are index
arguments has no constructor $\make^I_\ell \vec p \meta y_1 \ldots$
which can construct such an object.




\subsection{Exhaustiveness and Redundancy}
%------------------------------------------------------------

\emph{Focal point}
Each pattern in a pattern clause can be regarded as a focal
point. At the focal point we have either a variable, a constructor pattern or a
constant. The focal point of two consecutive clauses is the first pattern where
both clauses have a different pattern (we do not regard $p$ and $x:=p$ as
different).

If two consecutive clauses don't have a focal point, then the second one is
redundant which is regarded as an error (the clause is unreachable).








\subsection{Application of a pattern match expression}

An application of a pattern match expression (whose type is always a function
type) has the form
$$
(\case \ldots) \vec a
$$
where $\vec a = [a_1, \ldots, a_n]$ are the arguments to which the pattern match
function is applied. The maximal number of arguments is determined by the type
$F$ of the pattern match expression.

The application can be evaluated if it is possible to find a clause of the
pattern match expression and split the arguments $\vec a$ into subexpressions
$\vec s$ and evaluate $(\lambda \Delta. e^E) \vec s$.




\subsection{Code Examples}
%----------------------------------------------------------------------




\begin{alba}
    type Vector (A: Any): Nat -> Any :=
        []:  Vector zero
        (::) {n: Nat}: A -> Vector n -> Vector (succ n)

    zip {A B: Any}
    : all {n}: Vector A n -> Vector B n -> Vector (A,B) n
    := case
        \ nil,     nil     := nil
        \ x :: xs, y :: ys := (x, y) :: zip xs ys
\end{alba}




\begin{alba}
    type (=) (A: Any): A -> A -> Prop :=
        same {x}: x = x

    zeroNeSucc: all {n: Natural}: zero = succ n -> False :=
        case
            -- no case clauses
\end{alba}

The compile has to verify that no match is possible. The pattern match
expression is the two argument function with type $\Pi n^N. 0 = 1 + n \to
\text{False}$.



\begin{alba}
    type Nat := [zero, succ: Nat -> Nat]

    (<=?): Nat -> Nat -> Nat := case
        [zero, _]        :=  true
        [succ _, zero]   :=  false
        [succ n, succ m] :=  n <=? m

    -- as case tree:
    case
        zero           :=   \ _ := true
        succ n :=
            case
                zero   :=   false
                succ m :=   n <=? m
\end{alba}
