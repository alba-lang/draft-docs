\section{Pattern Match}
%----------------------------------------------------------------------

\subsection{Basics}
%----------------------------------------------------------------------

Fully elaborated pattern match expression:
$$
\case[ f^F \mid c_1,  \ldots, c_n \mid t]
$$
%
where $F$ is a function type of the form
%
$$
\Pi x_1^{A_1} \ldots x_k^{A_k}. R
$$
%
and where each clause $c_i$ has the form
%
$$
    [\Delta \mid p_1^{P_1}, \ldots, p_m^{P_m} \mid e^E]
$$
where the context $\Delta$ contains all pattern variables introduced in the
pattern, $p_i$ is the $i$-th pattern
and $P_i$ is the corresponding type of the pattern, $e$ is the body of the
clause, $E$ its corresponding type and $t$ is a case tree (see below).

Each clause defines the function
$$
\lambda \Delta . e^E
$$


The patterns are terms generated from the grammar
$$
    p ::= x \mid x := c \mid x := \Make^I_\ell \vec q \vec p
$$
where $c$ ranges over constants (strings, characters, numbers, etc.), $x$ ranges
over variables and $p$ ranges over pattern. The expression $\Make^I_\ell \vec q
\vec p$ is the constructor with label $\ell$ of the inductive type $I$ applied to its
parameter arguments and to its arguments.

Patterns are trees. Each node of the tree is labelled by a pattern variable and
either by a constant or a constructor $\Make^I_\ell \vec q$. A pattern clause has a
sequence of trees.

The pattern variables are assumed to be distinct in all clauses.



\subsection{Welltyped}
%------------------------------------------------------------

A clause of the pattern match expression is welltyped if
$$
\begin{array}{lll}
    \Delta &\vdash& p_i : P_i
    \\
    \Delta &\vdash& e : E
\end{array}
$$
%
and
%
$$
\begin{array}{lll}
    P_i &\le& A_i[p_1,\ldots,p_{i-1} / x_1,\ldots,x_{i-1}]
    \\
    E   &\le& R[p_1,\ldots,p_m / x_1,\ldots,x_m]
\end{array}
$$
%
where $F = \Pi x_1^{A_1} \ldots x_m^{A_m}. R$.




\subsection{Syntactical Pattern}
%------------------------------------------------------------

The pattern in the source code are generated from the grammar
$$
\begin{array}{llll}
    p_s
    &:=&   x                   & \text{pattern variable}
    \\
    &\mid& \ell \vec p_s       & \text{constructor + arguments}
    \\
    &\mid& c                   & \text{constant}
    \\
    &\mid& x := \ell \vec p_s
    \\
    &\mid& x := c
\end{array}
$$


A constructor label $\ell$ without arguments and a variable name $x$ are
indistiguishable in the source code. They are just names. But since the required
type is known it is clear if the name is one of the labels of the corresponding
inductive type. In that case the name is a label and not a pattern variable.






\subsection{Case Tree}
%------------------------------------------------------------

A case expression is a function which can be applied to arguments
$$
    \case[\ldots] a_1 \ldots a_n
$$
%
The task of a valid case tree is to
\begin{itemize}
    \item split the arguments into a series of subterms $u_1,u_2, \ldots$

    \item decide which case clause is applicable (if sufficient information is
        available)

    \item return the result $e[u_1, u_2, \ldots / .]$ where $e$ is the right
        hand side of the applicable case clause.
\end{itemize}

A case tree is defined by the grammar

$$
    \begin{array}{lllll}
        t
        &::=& e
        %
        \\
        &\mid& [
            x^T
            \mid
            c_1 t_1, \ldots,  c_n t_n \mid
            \ell_1 t_1, \ldots, \ell_m t_m
            \mid
            d
        ]
    \end{array}
$$
%
where $n + m > 0$ and
%
\begin{center}
    \begin{tabular}{l p{8cm}}
        $t$ & case tree
        \\
        $d$ & optional case tree (default or catch all)
        \\
        $e$ & expression on the right hand side of a case clause
        \\
        $x^T$ & pattern variable with its corresponding type
        \\
        $c$ & constant
        \\
        $\ell$ & label of a constructor
    \end{tabular}
\end{center}

We can abbreviate the inner node by $[x^T \mid \vec c\vec t \mid
\vec\ell \vec t | d]$.


No duplicate constants and no duplicate labels are allowed in the second form of
an inner node.

Note that an inner node of the form $x \mid \empty \mid \empty \mid \empty]$ is
a leave node.

The application of a case tree scans the list of arguments left to write with a
pointer to a subexpression to some of its arguments. Semantic actions associated
to the nodes of a case tree.
\begin{itemize}
    \item $e$: The pointer has to point beyond the last argument of the
        arguments. The list of collected subexpression $u_1, u_2, \ldots$ cover
        all free variables in the expression $e$. Action: Return the value
        $e[u_1,u_2,\ldots / .]$.

    \item $[x^T \mid \vec c \vec t \mid \vec \ell \vec t \mid d]$:
        The pointer has to point to some subexpression of the arguments. The
        subexpression has to reduce to a head normal form which has either a
        constant or a constructor in the head position. From the constant or the
        constructor it is clear which case tree is the next to apply.
        Actions:
        \begin{itemize}
            \item Append the subexpression to the list $u_1,u_2,\ldots$.

            \item If the default tree is the next tree then apply it to the next
                pointer position.

            \item If the subexpression is a constant then apply the
                corresponding next tree to the next pointer position.

            \item If the subexpression is a constructor without index
                arguments then apply the corresponding next tree to the next
                pointer position.

            \item If the subexpression is a constructor with arguments then
                apply the corresponding next tree to the pointer pointing at the
                first index argument of the constructor (skip the parameter
                arguments).
        \end{itemize}
\end{itemize}



\paragraph{Exhaustiveness of inner nodes}
%

An inner node of the form $[x^T \mid \vec c \vec t \mid \vec\ell \vec t \mid d]$ is
exhaustive if it has a default tree or if all labels of constructors which can
construct an object of the corresponding type are present (none of the missing
constructors can construct an object of type $T$).

An empty inner node of the form $[x^T \mid \empty \mid \empty \mid \empty]$ is
possible if $T$ is an inductive type and none of the constructors of the
inductive type can construct an object of type $T$.

\paragraph{Exhaustiveness of a case tree}
%
A case tree is exhaustive if all its nodes are exhaustive.




\subsection{Case Tree Construction}
%------------------------------------------------------------

\paragraph{Case tree for a clause}
First we construct a case tree from a cause clause
$[\Delta \mid \vec p \mid e]$.

{
    \def\ct{f_\text{ct}}
    The case tree corresponding to $e$ is $e$. The case tree $\ct(p, t)$ of a
    pattern $p$ where $t$ is a partially constructed case tree is defined
    recursively
    $$
    \ct(p, t) := \left\{
        \begin{array}{lll}
            \ct(x,t)
            &:=&
            [x \mid \empty \mid \empty \mid t]
            \\
            \ct(x := c, t)
            &:=&
            [x \mid c t \mid \empty \mid \empty]
            \\
            \ct(x := \Make^\Ind_\ell \vec q \vec p, t)
            &:=&
            [x \mid \empty \mid \ell \ct(\vec p, t) \mid \empty]
        \end{array}
    \right.
    $$
    %
    where $\ct(\vec p, t)$ on a sequence of pattern is threaded from behind
    %
    $$
    \ct(p_1 \ldots p_{n-1} p_n, t)
    :=
    \ct(p_1, (\ldots \ct(p_{n-1}, \ct(p_n, t))\ldots))
    $$
    with the corner case $\ct(\empty, t) = t$.
    %
    The case tree of a case clause $[\Delta \mid \vec p \mid e]$ is defined as
    $\ct(\vec p, e)$.
}

Note that the case tree of a cause clause has no branching.
It is a path from the root to a leave.



\paragraph{Merge case trees} We have to be able to merge two case trees $t_1$
and $t_2$ to $m(t_1, t_2)$ where the first one might an already merged case tree
and the second one has been constructed from a clause of the pattern match
expression.

\noindent Error cases:
\begin{enumerate}
    \item $m(e, t)$: This case is ambiguous. The first case tree would return
        $e$, the second would apply $t$.

    \item $m(t, e)$: This cas is ambiguous as well. The first tree $t$ would be
        applied to deliver some result the second tree would immdiately return
        $e$.

    \item $m([x \mid . \mid . \mid t_1], [x \mid . \mid .
        \mid t_2]$: Ambiguous: Which default shall be taken?

    \item $m([x\mid . \mid \vec \ell \vec t_1 \mid \empty],
        [x \mid \empty \mid \empty \mid t_2])$ where $\vec \ell$ covers all
        possible constructors for the corresponding inductive type: Default case
        is redundant.

    \item $m([x\mid . \mid \vec \ell \vec t_1 \mid .],
        [x \mid ct_t \mid \empty \mid \empty])$ where $\vec \ell$ has at least
        one constructor: Out of order. All constants have to be merged before
        the first constructor case.
\end{enumerate}

\noindent Success cases:
\begin{enumerate}
    \item Merge a default tree: In the first case tree the top node must not be
        exhaustive.

    \item Merge an already available constant: Merge the subtrees corresponding
        to the constant.

    \item Merge a new constant: The top node of the first case tree must not yet
        have any constructors. Add the new constant and its case trees to the
        available constants and case trees.

    \item Merge an alreay available constructor: Merge the subtree corresponding
        to the constructor.

    \item Merge a new constructor: Add the new constructor with its case tree to
        the available constructors and their case trees.
\end{enumerate}

\paragraph{Algorithm}

\ \begin{enumerate}
    \item Construct a case tree from the first clause.

    \item For all remaining clauses: Construct a case tree from the clause and merge it
        into the existing case tree.

    \item Check if the constructed case tree is exhaustive.
\end{enumerate}

\paragraph{No case clauses} This is allowed only if in the type $\Pi x_1^{A_1}
\ldots x_k^{A_k}. R$ of the case expression there is one $A_i$ which is an
inductive type which cannot be constructed (e.g. $\text{False}$ or $\text{zero}
= \text{succ } n$).







\subsection{Application of a pattern match expression}

An application of a pattern match expression (whose type is always a function
type) has the form
$$
\case(f^F, \vec c) \vec a
$$
where $\vec a = [a_1, \ldots, a_n]$ are the arguments to which the pattern match
function is applied. The maximal number of arguments is determined by the type
$F$ of the pattern match expression.

The application can be evaluated if it is possible to find a clause of the
pattern match expression and split the arguments $\vec a$ into subexpressions
$\vec s$ and evaluate $(\lambda \Delta. e^E) \vec s$.

A pattern match expression applied to arguments is a reducible expression
$$
\case(f^F, \vec c) \vec a \quad\to\quad e[case(f^F, \vec c), \vec s / f, \vec x]
$$
where $e$ is the expression on the right hand side of the found clause, $\vec x$
are the pattern variables of this clause and $\vec s$ are the subexpressions
extracted from the arguments $\vec a$ during walking down the case tree. The
hole case expression is substituted for the variable $f$ representing the
function and the subexpressions $\vec s$ are substituted for the pattern
variables $\vec x$.



\subsection{Code Examples}
%----------------------------------------------------------------------



\paragraph{Unbounded Loop}

\ \begin{alba}
    section
        P: Nat -> Prop
        d: Decider P
        e: Exist P
    :=
        type R: Nat -> Nat -> Prop :=
                -- 'n' and its successor figure in the relation 'R'
                -- if 'n' does not satisfy the predicate.
            next {n}: not P n -> R n (succ n)

        type Via: Nat -> Prop :=
                -- Set of viable candidates: A number 'n' is in the
                -- set if all its successors in the relation 'R' are
                -- in the set.
            via {x}: (all {y}: R x y -> Via y) -> Via x

        stepDown {n} (v: Via (succ n)): Via n :=
            via {n} f where
                f: all {m}: R n m -> Via m
                := case
                    \ next _ : Via (succ n) := v
\end{alba}


\paragraph{Ackermann Function}

\ \begin{alba}
    ack: Nat -> Nat -> Nat := case
        \ zero  ,     n       :=  succ n
        \ succ m,     zero    :=  ack m (succ zero)
        \ k := succ m, succ n :=  ack m (ack k n)
\end{alba}

Proof of termination: In each recursive application either the first argument
decreases or the first argument remains the same and the second argument
decreases.


\paragraph{Vector}

\ \begin{alba}
    type Vec (A: Any): Nat -> Any :=
        []:  Vec zero
        (::) {n: Nat}: A -> Vec n -> Vec (succ n)

    zip {A B: Any}
    : all {n}: Vec A n -> Vec B n -> Vec (A,B) n
    := case
        \ nil,     nil     := nil
        \ x :: xs, y :: ys := (x, y) :: zip xs ys
\end{alba}

\begin{alba}
    map {A B C} (f: A -> B -> C)
        : all {n}
          : Vec A n -> Vec B n -> Vec C n
    := case
        \ {zero},   [],            [] :=
            []
        \ {succ n}, (::) {n} x xs, (::) {n} y ys :=
            (::) {n} (f x y) (map {n} xs ys)
        -- without implicits
        \ [] []            := []
        \ x :: xs, y :: ys := (f x y) (map xs ys)
\end{alba}





\paragraph{Less Equal on natural numbers}


\ \begin{alba}
    type (<=): Nat -> Nat -> Prop :=
        start {n}:    0 <= n
        next  {n m}:  n <= m -> succ n <= succ m

    leRefl: all {n: Nat}: n <= n := case
        \ {zero}   := start {zero}
        \ {succ n} := next {n} {n} (leRefl {n})

        -- without implicits
        \ {zero}   := start
        \ {succ n} := next leRefl
\end{alba}

Pattern match on implicits is allowed in this case, because the result type is a
proposition!




\paragraph{Equality}

\ \begin{alba}
    type (=) (A: Any): A -> A -> Prop :=
        same {x}: x = x

    zeroNeSucc: all {n: Nat}: zero = succ n -> False :=
        case
            -- no case clauses
\end{alba}

The compiler has to verify that no match is possible. The pattern match
expression is the two argument function with type $\Pi n^N. 0 = 1 + n \to
\text{False}$.



\paragraph{$<=?$}
\ \begin{alba}
    type Nat := [zero, succ: Nat -> Nat]

    (<=?): Nat -> Nat -> Nat := case
        \ zero,   _      :=  true
        \ succ _, zero   :=  false
        \ succ n, succ m :=  n <=? m

    -- as case tree:
    case
        zero           :=   \ _ := true
        succ n :=
            case
                zero   :=   false
                succ m :=   n <=? m
\end{alba}


\paragraph{Parity}
\ \begin{alba}
    type Parity: Nat -> Any :=
        even n: Parity (n + n)
        odd  n: Parity (succ (n + n))

    parity: all n: Parity n := case
        \ zero: Parity zero :=
            even
        \ succ n: Parity (succ n) :=
            match parity n case
                \ even nh :=
                    odd nh
                \ odd nh :=
                    even (succ nh)

    natToBin: Nat -> List Bool := case
        \ zero :=
            []
        \ succ n :=
            match parity n case
                \ even nh :=
                    false :: natToBin nh
                \ odd nh :=
                    true :: natToBin nh
\end{alba}
